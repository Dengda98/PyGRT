# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Zhu Dengda
# This file is distributed under the same license as the PyGRT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyGRT 0.6.1.dev1+g4641a40.d20250422\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-20 11:57+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: en\n"
"Language-Team: en <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../source/Tutorial/prepare.rst:2
msgid "准备工作"
msgstr "Preparation"

#: ../../source/Tutorial/prepare.rst
msgid "Author"
msgstr ""

#: ../../source/Tutorial/prepare.rst:4
msgid "Zhu Dengda"
msgstr ""

#: ../../source/Tutorial/prepare.rst
msgid "Email"
msgstr ""

#: ../../source/Tutorial/prepare.rst:5
msgid "zhudengda@mail.iggcas.ac.cn"
msgstr ""

#: ../../source/Tutorial/prepare.rst:9
msgid ""
"**PyGRT** 程序包由C和Python两个编程语言的代码组成，目的是兼并高效性和便捷性。 底层复杂运算由C语言编写，编译链接成动态库 "
"``libgrt.so`` 供Python调用。Python通过 ``ctypes`` "
"库导入动态库以使用外部函数，以此兼并了C语言的高效和Python语言的便捷。"
msgstr ""
"**PyGRT** package consists of code written in both C and Python, aiming "
"to combine efficiency and convenience. Underlying complex computations "
"are implemented in C, compiled and linked into a dynamic library "
"``libgrt.so`` for Python to call. Python uses the ``ctypes`` library to "
"import the dynamic library and utilize external functions, thus combining"
" the efficiency of C with the convenience of Python."

#: ../../source/Tutorial/prepare.rst:12
msgid ""
"除了Python脚本式运行， **PyGRT** 保留传统命令行式运行C程序 :command:`grt` 。 受 `GMT "
"<https://www.generic-mapping-tools.org/>`_ 的启发， :command:`grt` "
"程序对多个计算功能使用模块化管理， 可使用类似于以下格式来运行程序。每个模块可使用 ``-h`` 查看帮助。"
msgstr ""
"In addition to Python script execution, PyGRT retains the traditional "
"command-line C program :command:`grt`. Inspired by `GMT <https://www.generic-mapping-tools.org/>`_ , the :command:`grt` program "
"adopts a modular approach for its computational functions and can be executed "
"using a format similar to the following. Each module's help information can "
"be viewed using -h."

#: ../../source/Tutorial/prepare.rst:20
msgid "**C程序的运行独立于Python，不需要Python环境，从而满足了更多计算场景。**"
msgstr ""
"**The execution of C programs is independent of Python and "
"does not require a Python environment, thus enabling it to meet more computing scenarios.**"

#: ../../source/Tutorial/prepare.rst:22
msgid "计算 **动态解** 的主要计算流程如下："
msgstr ""
"The main computational process for calculating **dynamic solutions** is "
"as follows:"

#: ../../source/Tutorial/prepare.rst:24 ../../source/Tutorial/prepare.rst:125
msgid "Python"
msgstr ""

#: ../../source/Tutorial/prepare.rst:54
msgid "C (module name)"
msgstr ""

#: ../../source/Tutorial/prepare.rst:84
msgid "计算 **静态解** 的过程相同，只是在名称上有如下区别："
msgstr ""
"The process for calculating **static solutions** is the same, only the "
"function names and program names differ."

#: ../../source/Tutorial/prepare.rst:86
msgid ""
"Python 函数名称增加 \"static\\_\" ，例如 :func:`compute_static_grn() "
"<pygrt.pymod.PyModel1D.compute_static_grn>` 。"
msgstr ""
"Add \"static\\_\" in Python function names, e.g. :func:`compute_static_grn() <pygrt.pymod.PyModel1D.compute_static_grn>`."

#: ../../source/Tutorial/prepare.rst:87
msgid ""
"C 程序模块名增加 \"static\\_\" 前缀，例如 :command:`static_greenfn` ；或者在 "
":command:`grt` 与无 \"static\\_\" 前缀的模块名之间增加 \"static\" 命令， 即支持以下两种方式（以 "
":command:`greenfn` 模块为例）："
msgstr ""
"Add \"static\\_\" at the beginning of C module names, e.g. :command:`static_greenfn` ;"
"or replace the underline to a backspace, like the following."

#: ../../source/Tutorial/prepare.rst:97
msgid ""
"入门部分包含一些示例与说明，可快速上手。Github主页的 :rst:dir:`example/` 文件夹中有更多示例，可在 `Github "
"Releases <https://github.com/Dengda98/PyGRT/releases>`_ 中下载。"
msgstr ""
"The following are some simple tutorials to help you get started quickly. "
"More examples can be found in the :rst:dir:`example/` folder on the "
"Github homepage, which can be downloaded from `Github Releases "
"<https://github.com/Dengda98/PyGRT/releases>`_.

#: ../../source/Tutorial/prepare.rst:101
msgid "建立模型文件"
msgstr "Create model file"

#: ../../source/Tutorial/prepare.rst:106
msgid "这里的选项卡 **C** 不代表内部是C语言代码，而是 **使用C程序** :command:`grt` 。后续的选项卡沿用此设定，不再解释。"
msgstr ""
"The tab **C** here does not represent C language code inside, but rather "
"**an executable program :command:`grt` compiled using the C language** . "
"Subsequent tabs follow this convention and will not be explained further."

#: ../../source/Tutorial/prepare.rst:110
msgid "C"
msgstr ""

#: ../../source/Tutorial/prepare.rst:112
msgid "**PyGRT** 以如下自由格式定义模型中每层的物性参数，每列之间以空格隔开（最后两列的 Qp, Qs 可省略）"
msgstr ""
"**PyGRT** defines the physical parameters of each layer in the model "
"using the following free format, with columns separated by spaces."
"(The values of Qp and Qs in the last two columns can be omitted.)"

#: ../../source/Tutorial/prepare.rst:119
msgid "例如 :file:`milrow` 模型（假设文本文件名为 `milrow` ）"
msgstr ""
"For example, the :file:`milrow` model (assuming the text file is named "
"`milrow`)."

#: ../../source/Tutorial/prepare.rst:127
msgid "模型格式与C一致，在Python中可以使用 :code:`np.loadtxt()` 导入文本文件，或者手动定义数组"
msgstr ""
"The model format is consistent with C, and in Python, you can use "
":code:`np.loadtxt()` to import the text file or manually define the "
"array."

#: ../../source/Tutorial/prepare.rst:137
msgid "最后一行表示半空间，对应厚度值不会被使用。"
msgstr ""
"The last line represents the half-space, and the corresponding thickness "
"value will not be used."

#: ../../source/Tutorial/prepare.rst:141
msgid "Vs 设置为 0 表示该层为液体层。"
msgstr "Setting Vs to 0 indicates that this layer is a liquid layer."

