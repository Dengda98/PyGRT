# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Zhu Dengda
# This file is distributed under the same license as the PyGRT package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyGRT 0.6.1.dev1+g4641a40.d20250422\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-20 11:57+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: en\n"
"Language-Team: en <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../source/Tutorial/dynamic/gfunc.rst:2
msgid "计算动态格林函数"
msgstr "Compute Dynamic Green's Functions"

#: ../../source/Tutorial/dynamic/gfunc.rst
msgid "Author"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:4
msgid "Zhu Dengda"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst
msgid "Email"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:5
msgid "zhudengda@mail.iggcas.ac.cn"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:10
msgid ""
"Python中计算动态格林函数的主函数为 :func:`compute_grn() "
"<pygrt.pymod.PyModel1D.compute_grn>` ，C模块为 :command:`greenfn`。"
msgstr ""
"The main function for computing dynamic Green's functions in Python is "
":func:`compute_grn() <pygrt.pymod.PyModel1D.compute_grn>`, and the "
"corresponding C module is :command:`greenfn`."

#: ../../source/Tutorial/dynamic/gfunc.rst:12
msgid ""
"核心计算逻辑来自  :ref:`初稿 <yao_init_manuscripts>` ，具体代码可见与C API中对应同名 :file:`*.c`"
" 文件，其中计算格林函数频谱的主函数为 :file:`grn.c` 里的 "
":c:func:`integ_grn_spec`。输出结果的坐标系见下图。"
msgstr ""
"The core computation logic originates from :ref:`初稿 "
"<yao_init_manuscripts>`. The specific code can be found in the "
"corresponding :file:`*.c` files within the C API. The main function for "
"calculating the Green's functions spectra is :c:func:`integ_grn_spec` in "
":file:`grn.c`. The coordinate system for the output results is shown in "
"the figure below."

#: ../../source/Tutorial/dynamic/gfunc.rst:20
msgid ""
"**推导过程中定义的Z分量与C/Python输出的Z分量方向相反**。因为从Z轴向下为正的坐标系对于 **半无限水平分层均匀介质** "
"来讲更便于公式推导；而在结果输出后，会对Z分量取相反数，因为Z轴向上和目前实采数据使用的Z轴方向一致，这更便于后续数据处理。"
msgstr ""
"**The Z-component defined during the derivation process is opposite in "
"direction to the Z-component output by C/Python**. This is because a "
"coordinate system where the Z-axis is positive downward is more "
"convenient for formula derivation in a semi-infinite horizontally layered"
" homogeneous medium. However, after the results are output, the "
"Z-component is negated to align the Z-axis upward with the direction used"
" in current real-world data, making subsequent data processing more "
"convenient."

#: ../../source/Tutorial/dynamic/gfunc.rst:22
msgid ""
"除非特别指明（例如描述震源机制），且一般使用 **PyGRT** 时也不会涉及底层程序内部， **在实际使用过程中提及的Z轴均以向上为正** "
"，仅在讨论代码内部细节和公式推导时对此加以区分。"
msgstr ""
"Unless otherwise specified (e.g., describing the source mechanism), and "
"generally not involving the underlying program internals when using "
"**PyGRT**, **the Z-axis mentioned in practical usage is always considered"
" positive upward**, with distinctions made only when discussing internal "
"code details and formula derivations."

#: ../../source/Tutorial/dynamic/gfunc.rst:27
msgid "示例程序"
msgstr "Simple run"

#: ../../source/Tutorial/dynamic/gfunc.rst:29
msgid ""
"假设在 :file:`milrow` "
"模型中，震源深度2km，接收点位于地表，震中距为5km，8km和10km，计算格林函数，要求采样点数500个点，采样间隔0.02s。"
msgstr ""
"Assume in the :file:`milrow` model, the source depth is 2km, the receiver"
" is located on the surface, and the epicentral distances are 5km, 8km, "
"and 10km. Compute the Green's functions with 500 sampling points and a "
"sampling interval of 0.02s."

#: ../../source/Tutorial/dynamic/gfunc.rst:33
msgid "C"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:40
msgid ""
"不同震源深度、接收点深度和震中距的格林函数会在 :rst:dir:`GRN/milrow_{depsrc}_{deprcv}_{dist}/` "
"路径下，使用SAC格式保存。"
msgstr ""
"The Green's functions for different source depths, receiver depths, and "
"epicentral distances are saved in SAC format under the path "
":rst:dir:`GRN/milrow_{depsrc}_{deprcv}_{dist}/`."

#: ../../source/Tutorial/dynamic/gfunc.rst:42
msgid ""
"一些基本信息（包括源点和场点的物性参数）保存在SAC头段变量中，其中 :c:var:`t0` 和 :c:var:`t1` "
"分别代表初至P波和初至S波的到时。在不设定其它参数时，程序中使用0（发震时刻）作为参考时间，故其等价于走时。"
msgstr ""
"Some basic information (including physical parameters of the source and "
"field points) is stored in the SAC header variables, where :c:var:`t0` "
"and :c:var:`t1` represent the arrival times of the first P-wave and "
"S-wave, respectively. When no other parameters are set, the program uses "
"0 (the origin time) as the reference time, so they are equivalent to "
"travel times."

#: ../../source/Tutorial/dynamic/gfunc.rst:44
msgid ":command:`travt` 模块可以显式地再计算初至波走时，"
msgstr ""
"The :command:`travt` module can explicitly recalculate the travel times "
"of the first waves."

#: ../../source/Tutorial/dynamic/gfunc.rst:51
msgid "走时结果会输出到终端，"
msgstr "The travel time results will be output to the terminal."

#: ../../source/Tutorial/dynamic/gfunc.rst:56
msgid ""
"如果你没有安装SAC软件，可以使用Python的ObsPy库读取生成的SAC数据，或者使用 :command:`sac2asc` "
"模块临时将SAC格式文件转为如下的文本文件："
msgstr ""
"If you have not installed the SAC software, you can use Python's ObsPy "
"library to read the generated SAC data, or use the :command:`sac2asc` module "
"to temporarily convert SAC format files into the following text files:"

#: ../../source/Tutorial/dynamic/gfunc.rst:63
msgid "输出的文本文件如下，两列分别为时间点和幅值。这种输出仅保留波形信息，缺失SAC文件中的头段变量。"
msgstr ""
"The output text file is as follows, with two columns representing time "
"points and amplitudes, respectively. This output retains only waveform "
"information and lacks the header variables in the SAC file."

#: ../../source/Tutorial/dynamic/gfunc.rst:68
msgid "Python"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:75
msgid ""
"多个震中距的格林函数以列表形式返回，其中每个元素为 |Stream| 类。:class:`Trace.stats.sac` "
"中保存了SAC头段变量，与C程序输出保持一致。"
msgstr ""
"The Green's functions for multiple epicentral distances are returned as a"
" list, where each element is of the |Stream| class. The "
":class:`Trace.stats.sac` contains the SAC header variables, consistent "
"with the output of the C program."

#: ../../source/Tutorial/dynamic/gfunc.rst:80
msgid "格林函数计算结果的单位："
msgstr "Units of the computed Green's function results:"

#: ../../source/Tutorial/dynamic/gfunc.rst:82
msgid ""
"爆炸源：  :math:`10^{-20} \\, \\frac{\\text{cm}}{\\text{dyne} \\cdot "
"\\text{cm}}`"
msgstr ""
"Explosion:  :math:`10^{-20} \\, \\frac{\\text{cm}}{\\text{dyne} \\cdot "
"\\text{cm}}`"

#: ../../source/Tutorial/dynamic/gfunc.rst:83
msgid "单力源：  :math:`10^{-15} \\, \\frac{\\text{cm}}{\\text{dyne}}`"
msgstr "Single Force:  :math:`10^{-15} \\, \\frac{\\text{cm}}{\\text{dyne}}`"

#: ../../source/Tutorial/dynamic/gfunc.rst:84
msgid ""
"剪切源：  :math:`10^{-20} \\, \\frac{\\text{cm}}{\\text{dyne} \\cdot "
"\\text{cm}}`"
msgstr ""
"Shear:  :math:`10^{-20} \\, \\frac{\\text{cm}}{\\text{dyne} \\cdot "
"\\text{cm}}`"

#: ../../source/Tutorial/dynamic/gfunc.rst:85
msgid ""
"矩张量源： :math:`10^{-20} \\, \\frac{\\text{cm}}{\\text{dyne} \\cdot "
"\\text{cm}}`"
msgstr ""
"Moment Tensor: :math:`10^{-20} \\, \\frac{\\text{cm}}{\\text{dyne} \\cdot"
" \\text{cm}}`"

#: ../../source/Tutorial/dynamic/gfunc.rst:90
msgid "离散波数积分"
msgstr "Discrete wavenumber integration"

#: ../../source/Tutorial/dynamic/gfunc.rst:92
msgid "格林函数频谱的计算本质转化为求以下积分:"
msgstr ""
"The essence of calculating the Green's functions spectra is transformed "
"into solving the following integrals:"

#: ../../source/Tutorial/dynamic/gfunc.rst:94
msgid "P_m(\\omega) = \\int_0^\\infty F_m(k, \\omega)J_m(kr)kdk"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:98
msgid ""
"其中 :math:`F_m(k,\\omega)` 称为核函数，它是和介质属性相关的量，与震中距无关。我们可以使用离散波数积分法 "
":ref:`(Bouchon, 1981) <bouchon_1981>` 将上式积分转变为求和:"
msgstr ""
"Here, :math:`F_m(k,\\omega)` is called the kernel function, which is "
"related to the medium properties and independent of the epicentral "
"distance. We can use the discrete wavenumber integration method "
":ref:`(Bouchon, 1981) <bouchon_1981>` to transform the above integral "
"into a summation:"

#: ../../source/Tutorial/dynamic/gfunc.rst:100
msgid ""
"P_m(\\omega) = \\Delta k \\sum_{j=0}^{\\infty} F_m(k_j,\\omega)J_m(k_j "
"r)k_j"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:104
msgid "其中 :math:`\\Delta k = 2\\pi/L, k_j=j\\Delta k`，:math:`L` 为特征长度，要求满足:"
msgstr ""
"where :math:`\\Delta k = 2\\pi/L, k_j=j\\Delta k`, and :math:`L` is the "
"characteristic length, which must satisfy:"

#: ../../source/Tutorial/dynamic/gfunc.rst:106
msgid ""
"\\left\\{\n"
"\\begin{aligned}\n"
"& r < L/2   \\\\\n"
"& (L-r)^2 + z_s^2 > (\\alpha T)^2\n"
"\\end{aligned}\n"
"\\right."
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:115
msgid ""
"其中 :math:`\\alpha` 为参考P波速度， :math:`T` 为所需计算的理论地震图的总时间长度。常见的保守经验值为 "
":math:`L=20r` ，但也应依具体情况而定 。为了避开附加源以及奇点的影响，:ref:`(Bouchon, 1981) "
"<bouchon_1981>`  在频率上添加微小虚部，具体推导过程详见 :ref:`(Bouchon, 1981) "
"<bouchon_1981>` 和 :ref:`(张海明, 2021) <zhang_book_2021>`。"
msgstr ""
"Here, :math:`\\alpha` represents the reference P-wave velocity, and "
":math:`T` is the total time length of the theoretical seismogram to be "
"calculated. A common conservative empirical value is :math:`L=20r`, but "
"it should be determined based on specific circumstances. To avoid the "
"influence of additional sources and singularities, :ref:`(Bouchon, 1981) "
"<bouchon_1981>` introduces a small imaginary part in the frequency. For "
"detailed derivation, refer to :ref:`(Bouchon, 1981) <bouchon_1981>` and "
":ref:`(Zhang Haiming, 2021) <zhang_book_2021>`."

#: ../../source/Tutorial/dynamic/gfunc.rst:121
msgid "积分形式分类"
msgstr "Types of integral forms"

#: ../../source/Tutorial/dynamic/gfunc.rst:123
msgid ""
"通过在面谐矢量坐标系中建立波函数进行公式推导，最终格林函数的三分量频谱 :math:`W_m(\\omega), Q_m(\\omega), "
"V_m(\\omega)` (分别为垂向，径向，切向)可以表达为:"
msgstr ""
"By constructing wave functions in the surface harmonic vector coordinate "
"system for formula derivation, the three-component spectra of the Green's"
" function :math:`W_m(\\omega), Q_m(\\omega), V_m(\\omega)` (representing "
"vertical, radial, and tangential components, respectively) can be "
"expressed as:"

#: ../../source/Tutorial/dynamic/gfunc.rst:125
msgid ""
"\\left\\{\n"
"\\begin{aligned}\n"
"W_m(\\omega) &= \\int_0^\\infty w_m J_m(kr)kdk  \\\\\n"
"Q_m(\\omega) &= \\int_0^\\infty (q_m J_m^{\\prime}(kr) - v_m "
"\\frac{m}{kr} J_m(kr)) kdk  \\\\\n"
"V_m(\\omega) &= \\int_0^\\infty (q_m \\frac{m}{kr} J_m(kr) - v_m  "
"J_m^{\\prime}(kr)) kdk\n"
"\\end{aligned}\n"
"\\right."
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:137
msgid ""
"初次推导该公式可能会对虚数 :math:`i` 及公式中的正负号感到疑惑，但其实这里的设计是将虚数 :math:`i` 和方向因子 "
":math:`e^{im\\theta}` 合并，所以在后续合成理论地震图时你会发现，:math:`m=0,1,2` 阶的 :math:`W_m,"
" Q_m` 的方向因子对 :math:`(m\\theta)` 的偏导就是 :math:`V_m` 的方向因子。"
msgstr ""
"When first deriving this formula, one might feel confused about the "
"imaginary unit :math:`i` and the signs in the formula. However, the "
"design here combines the imaginary unit :math:`i` with the directional "
"factor :math:`e^{im\\theta}`. Therefore, when synthesizing theoretical "
"seismograms later, you will find that the directional factor of "
":math:`W_m` and :math:`Q_m` for orders :math:`m=0,1,2` corresponds to the"
" directional derivative of :math:`V_m` with respect to "
":math:`(m\\theta)`."

#: ../../source/Tutorial/dynamic/gfunc.rst:140
msgid ""
"公式来自 :ref:`初稿 <yao_init_manuscripts>` (5.6.22)式，其中阶数 :math:`m=0,1,2`。核函数 "
":math:`q_m,w_m,v_m` "
"根据广义反射透射系数矩阵法(**GRTM**)求得，当震源比场点深时，有如下公式（震源浅于场点时有类似公式，这里不再展示）。"
msgstr ""
"The formula originates from :ref:`初稿 <yao_init_manuscripts>` Equation "
"(5.6.22), where the order :math:`m=0,1,2`. The kernel functions "
":math:`q_m,w_m,v_m` are derived using the Generalized Reflection and "
"Transmission matrix Method (**GRTM**). When the source is deeper than the"
" field point, the following formula applies (a similar formula exists for"
" cases where the source is shallower than the field point, which is not "
"shown here)."

#: ../../source/Tutorial/dynamic/gfunc.rst:142
msgid ""
"\\begin{aligned}\n"
"\\begin{bmatrix} q_m \\\\ w_m \\end{bmatrix} &=\n"
"\\mathbf{R}_{EV}(z_R) \\left(\\mathbf{I} - "
"\\mathbf{R}_D^{RS}\\mathbf{R}_U^{FR}\\right)^{-1} \\mathbf{T}_U^{RS}\n"
"\\left(\\mathbf{I} - \\mathbf{R}_D^{SL}\\mathbf{R}_U^{FS}\\right)^{-1}\n"
"\\left[\n"
"   \\mathbf{R}_D^{SL} \\begin{pmatrix} P_m^+ \\\\ SV_m^+ \\end{pmatrix} +"
" \\begin{pmatrix} P_m^- \\\\ SV_m^- \\end{pmatrix}\n"
"\\right] \\\\\n"
"v_m &= R_{EV,L}(z_R) \\left(I - R_{D,L}^{RS}R_{U,L}^{FR}\\right)^{-1} "
"T_{U,L}^{RS}\n"
"\\left(I - R_{D,L}^{SL}R_{U,L}^{FS}\\right)^{-1}\n"
"\\left[ R_{D,L}^{SL} SH_m^+ + SH_m^- \\right]\n"
"\\end{aligned}\n"
"\n"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:156
msgid ""
"为了方便程序实现，根据积分形式，我们对待求积分进行如下分类，其中每一阶都分为4类( :math:`p=0,1,2,3` )，除了0阶只需两类，此时"
" :math:`v_0=0` :"
msgstr ""
"For ease of program implementation, based on the integral forms, we "
"classify the integrals to be solved as follows. Each order is divided "
"into four types (:math:`p=0,1,2,3`), except for the 0th order, which "
"requires only two types, where :math:`v_0=0`:"

#: ../../source/Tutorial/dynamic/gfunc.rst:158
msgid ":math:`m=0`  [#]_"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:160
msgid ""
"\\left\\{\n"
"\\begin{aligned}\n"
"p=0 & \\rightarrow - \\int q_0(k, \\omega) J_1(kr)kdk \\\\\n"
"p=2 & \\rightarrow   \\int w_0(k, \\omega) J_0(kr)kdk\n"
"\\end{aligned}\n"
"\\right."
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:170
msgid ":math:`m=1,2`"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:172
msgid ""
"\\left\\{\n"
"\\begin{aligned}\n"
"p=0 & \\rightarrow   \\int q_m(k, \\omega) J_{m-1}(kr)kdk \\\\\n"
"p=1 & \\rightarrow - \\int (q_m(k, \\omega) + v_m(k, \\omega)) "
"\\frac{m}{kr} J_m(kr)kdk \\\\\n"
"p=2 & \\rightarrow   \\int w_m(k, \\omega) J_m(kr)kdk \\\\\n"
"p=3 & \\rightarrow - \\int v_m(k, \\omega) J_{m-1}(kr)kdk\n"
"\\end{aligned}\n"
"\\right."
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:184
msgid ""
"以上每个积分都形成 :math:`\\int_0^\\infty F_m(k, \\omega)J_m(kr)kdk` "
"的形式，便可逐个使用离散波数积分（或Filon积分、峰谷平均法等）求解每个积分。"
msgstr ""
"Each of the above integrals takes the form :math:`\\int_0^\\infty F_m(k, "
"\\omega)J_m(kr)kdk`, and each integral can be solved individually using "
"discrete wavenumber integration (or Filon integration, peak-trough "
"averaging method, etc.)."

#: ../../source/Tutorial/dynamic/gfunc.rst:186
msgid "感谢席超强博士 `@xichaoqiang <https://github.com/xichaoqiang>`_ 的订正。"
msgstr ""
"Thanks to Dr. Chaoqiang Xi `@xichaoqiang "
"<https://github.com/xichaoqiang>`_ for the corrections."

#: ../../source/Tutorial/dynamic/gfunc.rst:192
msgid "格林函数分类"
msgstr "Types of Green's Functions"

#: ../../source/Tutorial/dynamic/gfunc.rst:194
msgid "程序会输出15个格林函数（也可以选择输出哪些震源），但并不是每个震源类型对应的每一阶每种积分类型都存在。以下为15个格林函数定义的名称，以及对应上述的阶数以及积分类型:"
msgstr ""
"The program will output 15 Green's functions (or you can choose which "
"sources to output), but not every source type corresponds to every order "
"and every type of integral. Below are the names of the 15 defined Green's"
" functions, along with their corresponding orders and integral types:"

#: ../../source/Tutorial/dynamic/gfunc.rst:197
msgid "**名称**"
msgstr "**Name**"

#: ../../source/Tutorial/dynamic/gfunc.rst:197
msgid "**格林函数类型**"
msgstr "**Green's Function Type**"

#: ../../source/Tutorial/dynamic/gfunc.rst:197
msgid "**对应阶数**"
msgstr "**Order**"

#: ../../source/Tutorial/dynamic/gfunc.rst:197
msgid "**对应积分类型**"
msgstr "**Integral Type**"

#: ../../source/Tutorial/dynamic/gfunc.rst:199
msgid "EXZ"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:199
msgid "爆炸源Z分量"
msgstr "Explosion, Vertical Upward"

#: ../../source/Tutorial/dynamic/gfunc.rst:199
#: ../../source/Tutorial/dynamic/gfunc.rst:201
#: ../../source/Tutorial/dynamic/gfunc.rst:203
#: ../../source/Tutorial/dynamic/gfunc.rst:205
#: ../../source/Tutorial/dynamic/gfunc.rst:213
#: ../../source/Tutorial/dynamic/gfunc.rst:215
msgid ":math:`m=0`"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:199
#: ../../source/Tutorial/dynamic/gfunc.rst:203
#: ../../source/Tutorial/dynamic/gfunc.rst:207
#: ../../source/Tutorial/dynamic/gfunc.rst:213
#: ../../source/Tutorial/dynamic/gfunc.rst:217
#: ../../source/Tutorial/dynamic/gfunc.rst:223
msgid ":math:`p=2`"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:201
msgid "EXR"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:201
msgid "爆炸源R分量"
msgstr "Explosion, Radial Outward"

#: ../../source/Tutorial/dynamic/gfunc.rst:201
#: ../../source/Tutorial/dynamic/gfunc.rst:205
#: ../../source/Tutorial/dynamic/gfunc.rst:215
msgid ":math:`p=0`"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:203
msgid "VFZ"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:203
msgid "垂直向下力源Z分量"
msgstr "Vertical Downward Force, Vertical Upward"

#: ../../source/Tutorial/dynamic/gfunc.rst:205
msgid "VFR"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:205
msgid "垂直向下力源R分量"
msgstr "Vertical Downward Force, Radial Outward"

#: ../../source/Tutorial/dynamic/gfunc.rst:207
msgid "HFZ"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:207
msgid "水平力源Z分量"
msgstr "Horizontal Force, Vertical Upward"

#: ../../source/Tutorial/dynamic/gfunc.rst:207
#: ../../source/Tutorial/dynamic/gfunc.rst:209
#: ../../source/Tutorial/dynamic/gfunc.rst:211
#: ../../source/Tutorial/dynamic/gfunc.rst:217
#: ../../source/Tutorial/dynamic/gfunc.rst:219
#: ../../source/Tutorial/dynamic/gfunc.rst:221
msgid ":math:`m=1`"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:209
msgid "HFR"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:209
msgid "水平力源R分量"
msgstr "Horizontal Force, Radial Outward"

#: ../../source/Tutorial/dynamic/gfunc.rst:209
#: ../../source/Tutorial/dynamic/gfunc.rst:219
#: ../../source/Tutorial/dynamic/gfunc.rst:225
msgid ":math:`(p=0)+(p=1)`"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:211
msgid "HFT"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:211
msgid "水平力源T分量"
msgstr "Horizontal Force, Transverse Clockwise"

#: ../../source/Tutorial/dynamic/gfunc.rst:211
#: ../../source/Tutorial/dynamic/gfunc.rst:221
#: ../../source/Tutorial/dynamic/gfunc.rst:227
msgid ":math:`-(p=1)+(p=3)`"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:213
msgid "DDZ"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:213
msgid "倾角45度倾滑Z分量"
msgstr "45° dip slip, Vertical Upward"

#: ../../source/Tutorial/dynamic/gfunc.rst:215
msgid "DDR"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:215
msgid "倾角45度倾滑R分量"
msgstr "45° dip slip, Radial Outward"

#: ../../source/Tutorial/dynamic/gfunc.rst:217
msgid "DSZ"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:217
msgid "倾角90度倾滑Z分量"
msgstr "90° dip slip, Vertical Upward"

#: ../../source/Tutorial/dynamic/gfunc.rst:219
msgid "DSR"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:219
msgid "倾角90度倾滑R分量"
msgstr "90° dip slip, Radial Outward"

#: ../../source/Tutorial/dynamic/gfunc.rst:221
msgid "DST"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:221
msgid "倾角90度倾滑T分量"
msgstr "90° dip slip, Transverse Clockwise"

#: ../../source/Tutorial/dynamic/gfunc.rst:223
msgid "SSZ"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:223
msgid "倾角90度走滑Z分量"
msgstr "Vertical strike slip, Vertical Upward"

#: ../../source/Tutorial/dynamic/gfunc.rst:223
#: ../../source/Tutorial/dynamic/gfunc.rst:225
#: ../../source/Tutorial/dynamic/gfunc.rst:227
msgid ":math:`m=2`"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:225
msgid "SSR"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:225
msgid "倾角90度走滑R分量"
msgstr "Vertical strike slip, Radial Outward"

#: ../../source/Tutorial/dynamic/gfunc.rst:227
msgid "SST"
msgstr ""

#: ../../source/Tutorial/dynamic/gfunc.rst:227
msgid "倾角90度走滑T分量"
msgstr "Vertical strike slip, Transverse Clockwise"

